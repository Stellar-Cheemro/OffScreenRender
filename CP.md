## 实验目的

理解离屏渲染（Framebuffer）的基本概念与用途（如后期效果、离屏采样）。
理解单线程与多线程渲染架构的差异及其对 UI 响应与帧率的影响。
学会测量并比较不同 CPU/GPU 负载下的性能（FPS / 帧时），并能分析瓶颈来源。
掌握本项目中多线程实现的关键点：OpenGL 上下文共享、FBO 双缓冲、同步（fence / 原子变量 / 互斥）等。
能阅读并修改项目代码（src、shaders），实现简单的场景或模型替换以观察效果。

## 实验任务

前置说明：源码相关文件主要在 src（main.cpp、Scene.cpp、Worker.cpp、Renderer.cpp、Framebuffer.cpp、ScreenRenderer.cpp、Shader.h）与 shaders（GLSL）。所有任务均要求记录结果（截图或数据）、简短结论（每项 1-3 行）。
第一部分：单机/多负载对比（基础与探索）

1.运行程序并截取启动界面与默认控制面板的截图（提交截图）。
可运行可执行文件：OffScreenRender.exe 或相应配置路径。
2.熟悉并说明程序中的初始化流程（写出关键步骤，指明对应文件/函数），例如 OpenGL 初始化、窗口创建、ImGui 初始化（文件：main.cpp）。
3.找到并说明程序中模拟主线程 CPU 负载的位置（DoHeavyWork() 或类似函数），并记录默认行为（文件：main.cpp）。
4.修改或替换加载的模型/几何体：
在 Scene.cpp 中替换当前立方体为不同模型或更复杂顶点（若没有外部模型加载器，修改 Scene 的顶点生成或着色器以改变显示内容）。
运行并提交新模型下的截图（低、多、中、高复杂度三种情况）。
5.设计并执行性能对比矩阵（每组至少 10s 测试）：
x 轴：GPU 负载等级（低 / 中 / 高）——通过调节渲染耗时模拟，例如在 Scene::Draw() 中增加不同的 std::this_thread::sleep_for 值或渲染更多三角形。
y 轴：CPU 负载等级（低 / 中 / 高）——通过主界面的滑块或 DoHeavyWork() 参数控制。
对于每个组合，分别在“单线程”与“多线程”两种模式下记录平均 FPS 与帧时分布，保存截图或 CSV（说明测试时长与采样方法）。
6.分析结果：对比并回答——在哪些负载组合下多线程带来明显好处？在哪些情况下差别不大或更糟？请给出原因（考虑上下文切换、同步等待、GPU 饱和等）。

第二部分：多线程实现探究（核心）
7. 定位多线程实现代码（阅读并标注）：
查阅 Worker.cpp / Worker.h：说明 Worker 线程如何创建与运行（ThreadMain）、如何创建上下文、如何渲染到 FBO。
查阅 Framebuffer.cpp 与 ScreenRenderer.cpp：说明离屏纹理如何被主线程读取并显示。
8. 说明同步机制：
找出并说明使用到的同步原语（例如 glFenceSync、glClientWaitSync、std::atomic、互斥量等），并在报告中写出关键代码段位置（文件与行或函数名）。
9. 考虑与改进（理论与实践问题）：
是否存在更优的同步方法？列举并说明至少三种替代方案（例如：多缓冲/三缓冲减少等待、基于无锁队列传递命令、使用条件变量或信号量减少忙等候、使用 PBO 进行异步读写）。
互斥锁的替代：说明 std::atomic、读写锁（std::shared_mutex）、自旋锁、无锁环形缓冲（lock-free queue）的优缺点及适用场景。
对现有实现的具体改进建议（例如减少 glWaitSync 次数、增加缓冲槽数、合并小提交为批量提交、避免频繁切换 GL 上下文等），并指出在代码中应修改的模块（写出目标文件名）。
10. 小实验：实现并比较一种改进（可选 / 高级）：
示例：在 Worker -> 主线程交付纹理时改为三缓冲并测量差异；或将某个需要锁保护的共享变量改为 std::atomic 并验证是否可减少锁竞争。
提交修改的代码片段、运行截图与性能对比（简短结论）。

交付物与报告要求
提交内容：运行截图（必须）、一份短报告（包含测试方法、数据表/截图、结论、代码中关键修改点引用）、以及（可选）修改后的代码片段或补丁说明。
每项实验需写明测试平台（OS、CPU、GPU、驱动版本）、构建配置（Debug/Release）与测试时长。